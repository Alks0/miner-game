# 挖矿游戏 - 详细开发计划

## 📋 目录

1. [项目概述](#项目概述)
2. [技术架构](#技术架构)
3. [前端开发计划](#前端开发计划)
4. [后端开发计划](#后端开发计划)
5. [数据库设计](#数据库设计)
6. [API接口设计](#API接口设计)
7. [开发阶段规划](#开发阶段规划)
8. [部署与运维](#部署与运维)

---

## 项目概述

### 🎮 游戏简介
一款以矿工为主题的休闲挂机类H5游戏，融合了放置挂机、道具合成、PVP掠夺、虚拟交易所等多种玩法。

### 🎯 核心玩法
- **挖矿系统**：自动产出资源，具有暴击和坍塌机制
- **道具系统**：矿机、矿车、掠夺器、防御盾等多种可升级道具
- **合成升级**：碎片合成道具，道具可升级强化
- **掠夺系统**：PVP玩法，可掠夺其他玩家资源
- **交易所**：玩家间自由交易道具的虚拟市场
- **赛季制**：定期重置排行榜，增强竞争性

### 💰 商业模式
- 激励视频广告（主要收入来源）
- 免广告特权付费
- 道具礼包付费

---

## 技术架构

### 🏗️ 整体架构图

```
┌─────────────────────────────────────────────────────┐
│                   客户端层 (Client)                    │
│              Cocos Creator 3.x (H5/小程序)             │
│    ┌──────────┬──────────┬──────────┬──────────┐    │
│    │ 主界面   │ 仓库界面 │ 掠夺界面 │ 交易所   │    │
│    └──────────┴──────────┴──────────┴──────────┘    │
└────────────────────┬────────────────────────────────┘
                     │ HTTPS/WebSocket
┌────────────────────┴────────────────────────────────┐
│                   API网关层 (Gateway)                  │
│               身份验证 / 限流 / 路由                    │
└────────────────────┬────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────┐
│                 应用服务层 (Backend)                   │
│                  NestJS (Node.js)                     │
│    ┌──────────┬──────────┬──────────┬──────────┐    │
│    │用户服务  │游戏服务  │交易服务  │通知服务  │    │
│    └──────────┴──────────┴──────────┴──────────┘    │
└────────────────────┬────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────┐
│                   数据层 (Database)                    │
│         PostgreSQL (主库)    +    Redis (缓存)        │
└─────────────────────────────────────────────────────┘
```

### 📚 技术选型详解

#### 前端技术栈

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|------|---------|
| Cocos Creator | 3.8.x | 游戏引擎 | 专业H5游戏引擎，UI与跨平台表现稳定 |
| TypeScript | 5.x | 开发语言 | 类型安全，提高代码质量和可维护性 |
| Effect Shader/Material | 内置 | UI特效 | 实现紫蓝渐变、霓虹描边、发光、模糊等科技风效果 |
| SDF Font | - | 数字字体 | 高分辨率缩放清晰，适合大数字显示 |
| Tween.js | 内置 | 缓动动画 | 数值过渡、卡片滑入等轻量动画 |
| Graphics | 内置 | 可视化 | 折线/环形进度、指标曲线无DOM依赖 |

**前端目录结构**
```
assets/
├── scripts/              # 脚本目录
│   ├── core/            # 核心模块
│   │   ├── GameManager.ts      # 游戏管理器
│   │   ├── NetworkManager.ts   # 网络管理器
│   │   ├── AudioManager.ts     # 音频管理器
│   │   └── EventManager.ts     # 事件管理器
│   ├── scenes/          # 场景脚本
│   │   ├── MainScene.ts        # 主界面
│   │   ├── WarehouseScene.ts   # 仓库界面
│   │   ├── PlunderScene.ts     # 掠夺界面
│   │   └── ExchangeScene.ts    # 交易所界面
│   ├── components/      # 组件脚本
│   │   ├── ui/                 # UI组件
│   │   ├── game/               # 游戏组件
│   │   └── items/              # 道具组件
│   ├── data/            # 数据定义
│   │   ├── PlayerData.ts       # 玩家数据
│   │   ├── ItemData.ts         # 道具数据
│   │   └── GameConfig.ts       # 游戏配置
│   └── utils/           # 工具函数
├── resources/           # 动态资源
│   ├── prefabs/        # 预制件
│   ├── sprites/        # 图标、背景图
│   ├── fonts/          # 字体（科技感数字字体）
│   ├── materials/      # 材质（渐变/发光/描边/模糊）
│   ├── shaders/        # Effect( .effect/.chunk ) 自定义特效
│   ├── themes/         # 主题变量（colors.json、radius.json）
│   └── audio/          # 音效（可选）
└── scenes/             # 场景文件
```

#### 后端技术栈

| 技术 | 版本 | 用途 | 选型理由 |
|-----|------|------|---------|
| Node.js | 20.x LTS | 运行环境 | 高性能异步I/O，与前端技术栈统一 |
| NestJS | 10.x | Web框架 | 企业级架构，模块化设计，TypeScript原生支持 |
| TypeORM | 0.3.x | ORM框架 | 类型安全的数据库操作，支持迁移 |
| PostgreSQL | 15.x | 关系数据库 | ACID保证，适合交易等强一致性场景 |
| Redis | 7.x | 缓存/消息队列 | 高性能缓存，支持排行榜、会话管理 |
| Socket.io | 4.x | WebSocket | 实时通讯，兼容性好 |
| JWT | 9.x | 认证授权 | 无状态认证，易于扩展 |
| Bull | 4.x | 任务队列 | 异步任务处理（如挖矿产出计算） |

**后端目录结构**
```
src/
├── main.ts                    # 应用入口
├── app.module.ts              # 根模块
├── common/                    # 通用模块
│   ├── decorators/           # 装饰器
│   ├── filters/              # 异常过滤器
│   ├── guards/               # 守卫
│   ├── interceptors/         # 拦截器
│   ├── pipes/                # 管道
│   └── utils/                # 工具函数
├── config/                    # 配置模块
│   ├── database.config.ts
│   ├── redis.config.ts
│   └── game.config.ts
├── modules/                   # 业务模块
│   ├── auth/                 # 认证授权模块
│   │   ├── auth.controller.ts
│   │   ├── auth.service.ts
│   │   ├── auth.module.ts
│   │   ├── strategies/       # JWT/微信登录策略
│   │   └── dto/
│   ├── user/                 # 用户模块
│   │   ├── user.controller.ts
│   │   ├── user.service.ts
│   │   ├── user.module.ts
│   │   ├── entities/
│   │   └── dto/
│   ├── gameplay/             # 游戏玩法模块
│   │   ├── mine/            # 挖矿子模块
│   │   ├── item/            # 道具子模块
│   │   └── plunder/         # 掠夺子模块
│   ├── exchange/             # 交易所模块
│   │   ├── exchange.controller.ts
│   │   ├── exchange.service.ts
│   │   ├── exchange.module.ts
│   │   ├── matching.service.ts  # 撮合引擎
│   │   └── entities/
│   ├── notification/         # 通知模块
│   │   ├── notification.gateway.ts
│   │   ├── notification.service.ts
│   │   └── notification.module.ts
│   └── ranking/              # 排行榜模块
└── database/                 # 数据库相关
    ├── migrations/          # 迁移文件
    └── seeds/               # 种子数据
```

---

## 前端开发计划

### 1. 核心系统实现

#### 1.1 游戏管理器 (GameManager)

**功能职责**：
- 全局单例，管理游戏状态
- 玩家数据的本地缓存和同步
- 场景切换和生命周期管理

**核心代码结构**：
```typescript
// GameManager.ts
export class GameManager {
    private static _instance: GameManager;
    
    // 玩家数据
    private playerData: PlayerData;
    
    // 游戏配置
    private gameConfig: GameConfig;
    
    // 初始化
    public async init(): Promise<void>
    
    // 玩家数据管理
    public getPlayerData(): PlayerData
    public updatePlayerData(data: Partial<PlayerData>): void
    public syncPlayerData(): Promise<void>
    
    // 资源管理
    public addResource(type: ResourceType, amount: number): void
    public consumeResource(type: ResourceType, amount: number): boolean
}
```

#### 1.2 网络管理器 (NetworkManager)

**功能职责**：
- HTTP请求封装
- WebSocket连接管理
- 断线重连机制
- 请求队列和重试

**核心功能**：
```typescript
// NetworkManager.ts
export class NetworkManager {
    // HTTP请求
    public async request<T>(
        url: string, 
        method: string, 
        data?: any
    ): Promise<T>
    
    // WebSocket连接
    public connectWebSocket(): void
    public on(event: string, callback: Function): void
    public emit(event: string, data: any): void
    
    // 断线重连
    private reconnect(): void
}
```

#### 1.3 资源管理器

**功能职责**：
- 预加载游戏资源
- 动态加载和释放
- 资源缓存管理

#### 1.4 音频管理器

**功能职责**：
- 背景音乐播放
- 音效播放
- 音量控制

### 2. 界面模块开发

#### 2.1 主界面 (MainScene)

**UI布局（科技风卡片式）**：
```
┌─────────────────────────────────────┐
│ ┌──────────────────────────┐        │
│ │ 💎 矿石 12,450  🪙 BB币 5,230│     │ ← 顶部资源卡片（紫蓝渐变）
│ └──────────────────────────┘        │
│                                     │
│    ┌──────────────────────┐        │
│    │  ⛏️ 挖矿中...         │        │ ← 挖矿卡片（渐变圆角）
│    │  矿车: ████░░ 75%    │        │   进度条 + 实时产出数字
│    │  [收矿] 按钮          │        │   扁平科技按钮（霓虹描边）
│    └──────────────────────┘        │
│                                     │
│ ┌─────┬─────┬─────┬─────┬─────┐  │
│ │仓库 │掠夺 │交易 │排行 │设置 │  │ ← 底部 Tab（扁平图标）
│ └─────┴─────┴─────┴─────┴─────┘  │
└─────────────────────────────────────┘
```

**核心组件**：
- `ResourceCard`：资源卡片（渐变背景 + 数字过渡动画 + 高斯模糊玻璃）
- `MiningCard`：挖矿卡片（环形进度/速度表盘 + 实时数字更新）
- `ActionButton`：科技按钮（霓虹描边 + 内发光 + 点击涟漪）
- `TabBar`：底部导航（扁平图标 + 滑动指示器 + 毛玻璃底栏）
- `MetricTicker`：关键指标滚动条（收益、时速）

**关键功能**：
1. **挖矿产出展示**
   - 监听 WebSocket `mine.update` 事件
   - 普通产出：数字滚动过渡（CountUp 动画）
   - 暴击：卡片发光 + 数字放大脉冲
   - 坍塌：进度条变灰 + 倒计时数字

2. **收矿交互**
   - 点击科技按钮（霓虹边框高亮）
   - 判断是否有免广告特权
   - 无特权：播放广告后收矿
   - 有特权：直接收矿

3. **视觉效果（高级）**
   - 紫蓝径向+线性复合渐变；粒度噪声贴图叠加，增强质感
   - 毛玻璃（高斯模糊+半透明遮罩）与内外发光描边（Shader Material）
   - 数字滚动计数（Tween）+ 千位分隔 + 弹簧缓动
   - 点击涟漪（材质遮罩扩散）+ 卡片悬浮磁性吸附

#### 2.2 仓库界面 (WarehouseScene)

**UI布局（科技卡片列表）**：
```
┌─────────────────────────────────────┐
│ ┌───────┬───────┬───────┬───────┐  │
│ │ 全部  │ 矿机  │ 矿车  │ 装备  │  │ ← Tab（霓虹下划线）
│ └───────┴───────┴───────┴───────┘  │
│                                     │
│ ┌─────────────────────────────────┐│
│ │ ┌─────────────────────────┐    ││
│ │ │ 🔧 青铜矿机  Lv.5       │    ││ ← 卡片（渐变背景）
│ │ │ [装备] [升级]           │    ││   扁平按钮
│ │ └─────────────────────────┘    ││
│ │ ┌─────────────────────────┐    ││
│ │ │ 🚜 木制矿车  Lv.8       │    ││
│ │ │ [装备] [升级]           │    ││
│ │ └─────────────────────────┘    ││
│ └─────────────────────────────────┘│
│                                     │
│             [返回] 按钮             │
└─────────────────────────────────────┘
```

**核心功能**：
1. **道具列表展示**
   - 使用 ScrollView + Prefab 实现
   - 卡片式布局（渐变背景 + 圆角阴影）
   - 点击道具弹出详情弹窗（底部抽屉动画）

2. **道具详情弹窗**
```
┌──────────────────────────┐
│  ┌────────┐              │
│  │ 道具图标 │  道具名称+10 │
│  └────────┘              │
│                          │
│  属性: 挖矿效率 +50%      │
│                          │
│  升级材料:                │
│  - 碎片 x 50  (拥有: 30) │
│  - BB币 x 1000           │
│  成功率: 75%             │
│                          │
│  [升级] [合成] [取消]     │
└──────────────────────────┘
```

3. **升级/合成效果**
   - 点击按钮→扣除材料→服务器计算结果
   - 成功：卡片发光脉冲 + 等级数字滚动提升
   - 失败：卡片震动 + 红色闪烁提示

#### 2.3 掠夺界面 (PlunderScene)

**UI布局**：
```
┌─────────────────────────────────────┐
│       可掠夺玩家列表                 │
│ ┌─────────────────────────────────┐│
│ │ ┌──┐ 玩家A  Lv.12 【掠夺】      ││
│ │ │头│ 预估: 矿石 500             ││
│ │ └──┘                            ││
│ │ ┌──┐ 玩家B  Lv.15 【掠夺】      ││
│ │ │头│ 预估: 矿石 800             ││
│ │ └──┘                            ││
│ │ ┌──┐ 玩家C  Lv.10 【掠夺】      ││
│ │ │头│ 预估: 矿石 300             ││
│ │ └──┘                            ││
│ └─────────────────────────────────┘│
│                                     │
│  我的掠夺器: Lv.5   冷却: 00:00    │
│             [返回] 按钮             │
└─────────────────────────────────────┘
```

**核心功能**：
1. **掠夺目标列表**
   - 获取可掠夺玩家（等级相近）
   - 显示预估可掠夺资源
   - 掠夺冷却时间管理

2. **掠夺战斗流程**
   - 点击掠夺按钮
   - 播放简单战斗动画（3-5秒）
   - 显示结算弹窗（获得资源、复仇按钮）

3. **复仇系统**
   - 被掠夺后可复仇（限时）
   - 复仇成功双倍奖励

#### 2.4 交易所界面 (ExchangeScene)

**UI布局**：
```
┌─────────────────────────────────────┐
│ ┌──────┬──────┬──────┬──────┐      │
│ │ 市场 │ 挂单 │ 订单 │ 行情 │      │ ← Tab切换
│ └──────┴──────┴──────┴──────┘      │
│                                     │
│ 【市场页】                          │
│ ┌─────────────────────────────────┐│
│ │ 道具: [下拉选择框]              ││
│ │                                 ││
│ │ 卖单列表:                       ││
│ │ 价格: 1000  数量: 5  [购买]    ││
│ │ 价格: 1050  数量: 3  [购买]    ││
│ │                                 ││
│ │ 买单列表:                       ││
│ │ 价格: 950   数量: 10 [出售]    ││
│ │ 价格: 900   数量: 8  [出售]    ││
│ └─────────────────────────────────┘│
│                                     │
│ 我的资产: BB币 5,230                │
│ [挂买单] [挂卖单] [返回]            │
└─────────────────────────────────────┘
```

**核心功能**：
1. **市场数据展示**
   - 实时买卖挂单列表
   - 最新成交价格
   - 价格走势图（可选）

2. **挂单交易**
   - 挂买单：输入价格和数量，锁定BB币
   - 挂卖单：选择道具，锁定库存
   - 撤单：解锁资源

3. **订单管理**
   - 查看我的挂单（进行中）
   - 查看历史成交

4. **价格走势**
   - 使用Canvas绘制简易折线图
   - 显示近7天/24小时价格走势

### 3. 通用UI组件（科技风高级效果）

#### 3.1 弹窗组件 (Dialog)
- 确认弹窗（渐变卡片 + 模糊背景）
- 提示弹窗（顶部滑入 Toast）
- 输入弹窗（霓虹描边输入框）

#### 3.2 数字组件 (CountUpText)
- 资源增加滚动计数
- 大数字格式化（12,450）

#### 3.3 玻璃卡片 (GlassCard)
- 毛玻璃材质（背景采样 + 模糊 + 噪声）
- 内外发光描边（可调色/强度/半径）

#### 3.4 加载组件 (Loading)
- 全屏加载（圆环进度 + 渐变旋转）
- 按钮加载状态（霓虹边框脉冲）

#### 3.5 Toast组件
- 轻提示消息（半透明卡片 + 淡入淡出）

#### 3.6 进度条组件 (ProgressBar)
- 渐变填充进度条
- 圆环进度（挖矿状态）

#### 3.7 图表组件 (Charts)
- 产出折线图（Bezier 平滑 + 渐变填充）
- 仓位占比环图（空心环 + 中心数字）

### 4. 数据管理

#### 4.1 本地存储
```typescript
// LocalStorage.ts
export class LocalStorage {
    // 保存玩家Token
    public static saveToken(token: string): void
    
    // 保存游戏设置
    public static saveSettings(settings: GameSettings): void
    
    // 保存缓存数据
    public static saveCache(key: string, data: any): void
}
```

#### 4.2 数据同步策略
- 关键数据（资源、道具）：每次操作后立即同步
- 非关键数据（设置）：延迟同步
- 断线重连后：全量同步玩家数据

---

## 后端开发计划

> 默认运行模式（本地单机）：仅依赖 JWT + WebSocket + 内存存储即可跑通完整前端流程。PostgreSQL / Redis / Bull / TypeORM 等均为“可选扩展”，按需开启。文档内所有数据库/部署相关章节均视为可选，不影响本地功能验证。

### 1. 基础设施搭建

#### 1.1 项目初始化

本地最小依赖（内存模式即可运行）：
```bash
# 创建项目
npm i -g @nestjs/cli
nest new mining-game-backend

# 必需依赖（本地单机）
npm install --save @nestjs/jwt @nestjs/passport passport passport-jwt
npm install --save @nestjs/websockets @nestjs/platform-socket.io
npm install --save class-validator class-transformer
```

可选扩展依赖（需要数据库/消息队列时再安装）：
```bash
npm install --save @nestjs/typeorm typeorm pg
npm install --save redis ioredis
npm install --save @nestjs/bull bull
```

#### 1.2 配置管理（可选，当启用数据库/Redis时）

```typescript
// config/database.config.ts
export default registerAs('database', () => ({
  type: 'postgres',
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT) || 5432,
  username: process.env.DB_USERNAME || 'postgres',
  password: process.env.DB_PASSWORD || 'password',
  database: process.env.DB_NAME || 'mining_game',
  entities: ['dist/**/*.entity{.ts,.js}'],
  synchronize: process.env.NODE_ENV === 'development',
  logging: process.env.NODE_ENV === 'development',
}));

// config/redis.config.ts
export default registerAs('redis', () => ({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT) || 6379,
  password: process.env.REDIS_PASSWORD || '',
  db: parseInt(process.env.REDIS_DB) || 0,
}));
```

### 2. 模块开发详解（本地最小可用 + 可选扩展）

#### 2.1 认证授权模块 (Auth Module)

**功能清单（本地最小）**：
- 用户注册/登录（JWT）
- Token 校验与受保护接口

**可选扩展**：
- 微信H5授权登录
- Token 刷新机制

**核心代码**：

```typescript
// auth/auth.service.ts
@Injectable()
export class AuthService {
  constructor(
    private userService: UserService,
    private jwtService: JwtService,
  ) {}

  // 用户登录
  async login(loginDto: LoginDto): Promise<LoginResponse> {
    const user = await this.userService.validateUser(
      loginDto.username,
      loginDto.password,
    );
    
    if (!user) {
      throw new UnauthorizedException('用户名或密码错误');
    }
    
    const payload = { sub: user.id, username: user.username };
    return {
      access_token: this.jwtService.sign(payload),
      user: user,
    };
  }

  // 微信登录
  async wechatLogin(code: string): Promise<LoginResponse> {
    // 1. 通过code获取微信用户信息
    const wechatUserInfo = await this.getWechatUserInfo(code);
    
    // 2. 查找或创建用户
    let user = await this.userService.findByWechatOpenId(
      wechatUserInfo.openid,
    );
    
    if (!user) {
      user = await this.userService.createFromWechat(wechatUserInfo);
    }
    
    // 3. 生成Token
    const payload = { sub: user.id, username: user.username };
    return {
      access_token: this.jwtService.sign(payload),
      user: user,
    };
  }
}

// auth/auth.controller.ts
@Controller('api/auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Post('wechat-login')
  async wechatLogin(@Body('code') code: string) {
    return this.authService.wechatLogin(code);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}
```

#### 2.2 用户模块 (User Module)

**数据模型**：

```typescript
// user/entities/user.entity.ts
@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  username: string;

  @Column({ select: false })
  password: string;

  @Column({ nullable: true })
  wechat_openid: string;

  @Column({ default: '' })
  nickname: string;

  @Column({ default: '' })
  avatar: string;

  @Column({ type: 'int', default: 1 })
  level: number;

  @Column({ type: 'bigint', default: 0 })
  ore_amount: number;

  @Column({ type: 'bigint', default: 0 })
  bb_coins: number;

  @Column({ type: 'bigint', default: 0 })
  experience: number;

  @Column({ type: 'boolean', default: false })
  is_vip: boolean;

  @Column({ type: 'timestamp', nullable: true })
  vip_expire_at: Date;

  @CreateDateColumn()
  created_at: Date;

  @UpdateDateColumn()
  updated_at: Date;
}
```

**服务实现**：

```typescript
// user/user.service.ts
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    private redisService: RedisService,
  ) {}

  // 获取用户信息
  async findById(id: string): Promise<User> {
    // 先从缓存读取
    const cached = await this.redisService.get(`user:${id}`);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // 缓存未命中，从数据库读取
    const user = await this.userRepository.findOne({ where: { id } });
    
    // 写入缓存（30分钟过期）
    await this.redisService.setex(
      `user:${id}`,
      1800,
      JSON.stringify(user),
    );
    
    return user;
  }

  // 增加资源
  async addResource(
    userId: string,
    resourceType: 'ore' | 'coin',
    amount: number,
  ): Promise<void> {
    const field = resourceType === 'ore' ? 'ore_amount' : 'bb_coins';
    
    await this.userRepository.increment(
      { id: userId },
      field,
      amount,
    );
    
    // 清除缓存
    await this.redisService.del(`user:${userId}`);
  }

  // 扣除资源（原子操作）
  async consumeResource(
    userId: string,
    resourceType: 'ore' | 'coin',
    amount: number,
  ): Promise<boolean> {
    const field = resourceType === 'ore' ? 'ore_amount' : 'bb_coins';
    
    const result = await this.userRepository
      .createQueryBuilder()
      .update(User)
      .set({ [field]: () => `${field} - ${amount}` })
      .where('id = :userId', { userId })
      .andWhere(`${field} >= :amount`, { amount })
      .execute();
    
    if (result.affected > 0) {
      await this.redisService.del(`user:${userId}`);
      return true;
    }
    
    return false;
  }
}
```

#### 2.3 挖矿模块 (Mine Module)

**核心逻辑**：

```typescript
// gameplay/mine/mine.service.ts
@Injectable()
export class MineService {
  constructor(
    private userService: UserService,
    private itemService: ItemService,
    private notificationService: NotificationService,
    @InjectQueue('mine') private mineQueue: Queue,
  ) {}

  // 开始挖矿
  async startMining(userId: string): Promise<void> {
    // 获取玩家矿机等级
    const miner = await this.itemService.getUserEquippedItem(
      userId,
      'miner',
    );
    
    // 计算产出间隔（基础60秒，矿机每级-2秒）
    const baseInterval = 60;
    const minerLevel = miner?.level || 1;
    const interval = Math.max(10, baseInterval - minerLevel * 2);
    
    // 添加到任务队列
    await this.mineQueue.add(
      'produce',
      { userId },
      {
        repeat: { every: interval * 1000 },
        jobId: `mine:${userId}`,
      },
    );
  }

  // 处理挖矿产出（由Queue Worker调用）
  @Process('produce')
  async handleMineProduce(job: Job<{ userId: string }>): Promise<void> {
    const { userId } = job.data;
    
    // 检查矿洞是否坍塌中
    const isCollapsed = await this.isMineColla(userId);
    if (isCollapsed) {
      return;
    }
    
    // 获取玩家矿机等级
    const miner = await this.itemService.getUserEquippedItem(
      userId,
      'miner',
    );
    const minerLevel = miner?.level || 1;
    
    // 计算基础产出（矿机每级+10）
    const baseOutput = 10 + minerLevel * 10;
    
    // 随机事件判定
    const random = Math.random();
    let produceType: 'normal' | 'critical' | 'collapse';
    let finalOutput: number;
    
    if (random < 0.05) {
      // 5% 坍塌
      produceType = 'collapse';
      finalOutput = 0;
      
      // 设置坍塌状态（2分钟）
      await this.setMineCollapse(userId, 120);
    } else if (random < 0.30) {
      // 25% 暴击（3倍产出）
      produceType = 'critical';
      finalOutput = baseOutput * 3;
    } else {
      // 70% 普通产出
      produceType = 'normal';
      finalOutput = baseOutput;
    }
    
    // 检查矿车容量
    const cart = await this.itemService.getUserEquippedItem(
      userId,
      'cart',
    );
    const cartCapacity = (cart?.level || 1) * 1000;
    
    let currentAmount = await this.getCurrentCartAmount(userId);
    
    if (currentAmount + finalOutput > cartCapacity) {
      finalOutput = cartCapacity - currentAmount;
    }
    
    // 更新矿车存储
    await this.addToCart(userId, finalOutput);
    
    // 通过WebSocket推送给客户端
    this.notificationService.emitToUser(userId, 'mine.update', {
      type: produceType,
      amount: finalOutput,
      cartAmount: currentAmount + finalOutput,
      cartCapacity: cartCapacity,
    });
    
    // 坍塌通知
    if (produceType === 'collapse') {
      this.notificationService.emitToUser(userId, 'mine.collapse', {
        repair_duration: 120,
      });
    }
  }

  // 收矿
  async collectOre(userId: string, watchedAd: boolean): Promise<number> {
    // 检查是否需要观看广告
    const isVip = await this.userService.isVip(userId);
    if (!isVip && !watchedAd) {
      throw new BadRequestException('请先观看广告');
    }
    
    // 获取矿车当前存储
    const cartAmount = await this.getCurrentCartAmount(userId);
    
    if (cartAmount === 0) {
      throw new BadRequestException('矿车为空');
    }
    
    // 转入玩家仓库
    await this.userService.addResource(userId, 'ore', cartAmount);
    
    // 清空矿车
    await this.clearCart(userId);
    
    return cartAmount;
  }

  // 辅助方法
  private async getCurrentCartAmount(userId: string): Promise<number> {
    const amount = await this.redisService.get(`cart:${userId}`);
    return parseInt(amount) || 0;
  }

  private async addToCart(userId: string, amount: number): Promise<void> {
    await this.redisService.incrby(`cart:${userId}`, amount);
  }

  private async clearCart(userId: string): Promise<void> {
    await this.redisService.del(`cart:${userId}`);
  }

  private async setMineCollapse(
    userId: string,
    seconds: number,
  ): Promise<void> {
    await this.redisService.setex(`collapse:${userId}`, seconds, '1');
  }

  private async isMineCollapsed(userId: string): Promise<boolean> {
    const collapsed = await this.redisService.get(`collapse:${userId}`);
    return collapsed === '1';
  }
}
```

#### 2.4 道具模块 (Item Module)

**数据模型**：

```typescript
// gameplay/item/entities/item-template.entity.ts
@Entity('item_templates')
export class ItemTemplate {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ type: 'enum', enum: ['miner', 'cart', 'raider', 'shield'] })
  category: string;

  @Column({ type: 'text' })
  description: string;

  @Column({ type: 'int' })
  max_level: number;

  @Column({ type: 'json' })
  upgrade_formula: any; // 升级公式配置
}

// gameplay/item/entities/user-item.entity.ts
@Entity('user_items')
export class UserItem {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column()
  user_id: string;

  @ManyToOne(() => ItemTemplate)
  @JoinColumn({ name: 'template_id' })
  template: ItemTemplate;

  @Column()
  template_id: string;

  @Column({ type: 'int', default: 1 })
  level: number;

  @Column({ type: 'boolean', default: false })
  is_equipped: boolean;

  @CreateDateColumn()
  created_at: Date;

  @UpdateDateColumn()
  updated_at: Date;
}
```

**合成/升级逻辑**：

```typescript
// gameplay/item/item.service.ts
@Injectable()
export class ItemService {
  constructor(
    @InjectRepository(UserItem)
    private userItemRepository: Repository<UserItem>,
    @InjectRepository(ItemTemplate)
    private itemTemplateRepository: Repository<ItemTemplate>,
    private userService: UserService,
  ) {}

  // 道具升级
  async upgradeItem(
    userId: string,
    itemId: string,
  ): Promise<{ success: boolean; newLevel?: number }> {
    const item = await this.userItemRepository.findOne({
      where: { id: itemId, user_id: userId },
      relations: ['template'],
    });

    if (!item) {
      throw new NotFoundException('道具不存在');
    }

    if (item.level >= item.template.max_level) {
      throw new BadRequestException('已达最高等级');
    }

    // 获取升级配置
    const upgradeConfig = item.template.upgrade_formula[item.level];
    
    // 检查并扣除材料
    const hasEnoughMaterials = await this.checkAndConsumeMaterials(
      userId,
      upgradeConfig.materials,
    );
    
    if (!hasEnoughMaterials) {
      throw new BadRequestException('材料不足');
    }

    // 根据成功率判定
    const successRate = this.calculateSuccessRate(item.level);
    const random = Math.random();
    
    if (random < successRate) {
      // 升级成功
      item.level += 1;
      await this.userItemRepository.save(item);
      
      // 高等级道具升级成功，全服广播
      if (item.level >= 10) {
        // 通过WebSocket广播
        this.notificationService.broadcastToAll('item.upgrade_success', {
          player: await this.userService.getNickname(userId),
          item: `${item.template.name} +${item.level}`,
        });
      }
      
      return { success: true, newLevel: item.level };
    } else {
      // 升级失败，材料已扣除
      return { success: false };
    }
  }

  // 计算成功率（AI精算序列）
  private calculateSuccessRate(currentLevel: number): number {
    // 等级越高，成功率越低
    const baseRate = 0.8;
    const decreasePerLevel = 0.05;
    return Math.max(0.1, baseRate - currentLevel * decreasePerLevel);
  }

  // 碎片合成道具
  async composeItem(
    userId: string,
    templateId: string,
  ): Promise<UserItem> {
    const template = await this.itemTemplateRepository.findOne({
      where: { id: templateId },
    });

    if (!template) {
      throw new NotFoundException('道具模板不存在');
    }

    // 检查碎片数量（假设需要50个碎片）
    const hasEnoughFragments = await this.consumeFragments(
      userId,
      templateId,
      50,
    );
    
    if (!hasEnoughFragments) {
      throw new BadRequestException('碎片不足');
    }

    // 创建新道具
    const newItem = this.userItemRepository.create({
      user_id: userId,
      template_id: templateId,
      level: 1,
      is_equipped: false,
    });

    return this.userItemRepository.save(newItem);
  }
}
```

#### 2.5 掠夺模块 (Plunder Module)

**核心逻辑**：

```typescript
// gameplay/plunder/plunder.service.ts
@Injectable()
export class PlunderService {
  constructor(
    private userService: UserService,
    private itemService: ItemService,
  ) {}

  // 获取可掠夺玩家列表
  async getPlunderTargets(
    userId: string,
  ): Promise<PlunderTarget[]> {
    const user = await this.userService.findById(userId);
    
    // 查询等级相近的玩家（±5级）
    const targets = await this.userRepository
      .createQueryBuilder('user')
      .where('user.id != :userId', { userId })
      .andWhere('user.level BETWEEN :minLevel AND :maxLevel', {
        minLevel: user.level - 5,
        maxLevel: user.level + 5,
      })
      .andWhere('user.ore_amount > :minOre', { minOre: 100 })
      .orderBy('RANDOM()')
      .limit(20)
      .getMany();
    
    // 计算预估可掠夺资源
    return targets.map(target => ({
      id: target.id,
      nickname: target.nickname,
      avatar: target.avatar,
      level: target.level,
      estimated_loot: Math.floor(target.ore_amount * 0.1),
    }));
  }

  // 执行掠夺
  async executePlunder(
    attackerId: string,
    defenderId: string,
  ): Promise<PlunderResult> {
    // 检查掠夺器冷却
    const canPlunder = await this.checkPlunderCooldown(attackerId);
    if (!canPlunder) {
      throw new BadRequestException('掠夺器冷却中');
    }
    
    // 获取双方装备
    const attackerRaider = await this.itemService.getUserEquippedItem(
      attackerId,
      'raider',
    );
    const defenderShield = await this.itemService.getUserEquippedItem(
      defenderId,
      'shield',
    );
    
    const attacker = await this.userService.findById(attackerId);
    const defender = await this.userService.findById(defenderId);
    
    // 计算掠夺率
    const raiderLevel = attackerRaider?.level || 1;
    const shieldLevel = defenderShield?.level || 1;
    
    // 基础掠夺率10%，掠夺器每级+1%，防御盾每级-0.5%
    let plunderRate = 0.1 + raiderLevel * 0.01 - shieldLevel * 0.005;
    plunderRate = Math.max(0.05, Math.min(0.3, plunderRate)); // 限制在5%-30%
    
    // 计算掠夺数量
    const lootAmount = Math.floor(defender.ore_amount * plunderRate);
    
    if (lootAmount === 0) {
      throw new BadRequestException('对方资源不足');
    }
    
    // 执行资源转移
    await this.userService.consumeResource(defenderId, 'ore', lootAmount);
    await this.userService.addResource(attackerId, 'ore', lootAmount);
    
    // 记录掠夺日志
    await this.logPlunder(attackerId, defenderId, lootAmount);
    
    // 设置掠夺器冷却（1小时）
    await this.setPlunderCooldown(attackerId, 3600);
    
    // 通知被掠夺者
    this.notificationService.emitToUser(defenderId, 'plunder.attacked', {
      attacker: attacker.nickname,
      loss: lootAmount,
    });
    
    return {
      success: true,
      loot_amount: lootAmount,
      can_revenge: true,
      revenge_expire: Date.now() + 24 * 3600 * 1000, // 24小时内可复仇
    };
  }
}
```

#### 2.6 交易所模块 (Exchange Module)

**数据模型**：

```typescript
// exchange/entities/exchange-order.entity.ts
@Entity('exchange_orders')
export class ExchangeOrder {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'user_id' })
  user: User;

  @Column()
  user_id: string;

  @ManyToOne(() => ItemTemplate)
  @JoinColumn({ name: 'item_template_id' })
  item_template: ItemTemplate;

  @Column()
  item_template_id: string;

  @Column({ type: 'enum', enum: ['buy', 'sell'] })
  type: string;

  @Column({ type: 'int' })
  price: number;

  @Column({ type: 'int' })
  amount: number;

  @Column({ type: 'int', default: 0 })
  filled_amount: number;

  @Column({
    type: 'enum',
    enum: ['pending', 'partial', 'filled', 'cancelled'],
    default: 'pending',
  })
  status: string;

  @CreateDateColumn()
  created_at: Date;

  @UpdateDateColumn()
  updated_at: Date;
}
```

**撮合引擎**：

```typescript
// exchange/matching.service.ts
@Injectable()
export class MatchingService {
  constructor(
    @InjectRepository(ExchangeOrder)
    private orderRepository: Repository<ExchangeOrder>,
    private userService: UserService,
    private itemService: ItemService,
  ) {}

  // 挂买单
  async placeBuyOrder(
    userId: string,
    itemTemplateId: string,
    price: number,
    amount: number,
  ): Promise<ExchangeOrder> {
    // 计算总价
    const totalCost = price * amount;
    
    // 扣除BB币
    const success = await this.userService.consumeResource(
      userId,
      'coin',
      totalCost,
    );
    
    if (!success) {
      throw new BadRequestException('BB币不足');
    }
    
    // 创建买单
    const order = this.orderRepository.create({
      user_id: userId,
      item_template_id: itemTemplateId,
      type: 'buy',
      price,
      amount,
      status: 'pending',
    });
    
    await this.orderRepository.save(order);
    
    // 尝试立即撮合
    await this.tryMatch(order);
    
    return order;
  }

  // 挂卖单
  async placeSellOrder(
    userId: string,
    itemInstanceId: string,
    price: number,
  ): Promise<ExchangeOrder> {
    // 获取道具
    const item = await this.itemService.findUserItem(userId, itemInstanceId);
    
    if (!item) {
      throw new NotFoundException('道具不存在');
    }
    
    if (item.is_equipped) {
      throw new BadRequestException('已装备的道具无法出售');
    }
    
    // 锁定道具（标记为交易中）
    await this.itemService.lockItem(itemInstanceId);
    
    // 创建卖单
    const order = this.orderRepository.create({
      user_id: userId,
      item_template_id: item.template_id,
      type: 'sell',
      price,
      amount: 1,
      status: 'pending',
    });
    
    await this.orderRepository.save(order);
    
    // 尝试立即撮合
    await this.tryMatch(order);
    
    return order;
  }

  // 撮合引擎
  private async tryMatch(order: ExchangeOrder): Promise<void> {
    if (order.type === 'buy') {
      // 买单，匹配价格<=买价的卖单
      const sellOrders = await this.orderRepository.find({
        where: {
          item_template_id: order.item_template_id,
          type: 'sell',
          status: In(['pending', 'partial']),
          price: LessThanOrEqual(order.price),
        },
        order: { price: 'ASC', created_at: 'ASC' },
      });
      
      for (const sellOrder of sellOrders) {
        if (order.filled_amount >= order.amount) {
          break;
        }
        
        await this.executeTrade(order, sellOrder);
      }
    } else {
      // 卖单，匹配价格>=卖价的买单
      const buyOrders = await this.orderRepository.find({
        where: {
          item_template_id: order.item_template_id,
          type: 'buy',
          status: In(['pending', 'partial']),
          price: MoreThanOrEqual(order.price),
        },
        order: { price: 'DESC', created_at: 'ASC' },
      });
      
      for (const buyOrder of buyOrders) {
        if (order.filled_amount >= order.amount) {
          break;
        }
        
        await this.executeTrade(buyOrder, order);
      }
    }
  }

  // 执行交易
  private async executeTrade(
    buyOrder: ExchangeOrder,
    sellOrder: ExchangeOrder,
  ): Promise<void> {
    // 计算本次成交数量
    const buyRemaining = buyOrder.amount - buyOrder.filled_amount;
    const sellRemaining = sellOrder.amount - sellOrder.filled_amount;
    const tradeAmount = Math.min(buyRemaining, sellRemaining);
    
    // 使用事务确保原子性
    await this.orderRepository.manager.transaction(async manager => {
      // 更新订单状态
      buyOrder.filled_amount += tradeAmount;
      sellOrder.filled_amount += tradeAmount;
      
      if (buyOrder.filled_amount >= buyOrder.amount) {
        buyOrder.status = 'filled';
      } else {
        buyOrder.status = 'partial';
      }
      
      if (sellOrder.filled_amount >= sellOrder.amount) {
        sellOrder.status = 'filled';
      } else {
        sellOrder.status = 'partial';
      }
      
      await manager.save([buyOrder, sellOrder]);
      
      // 转移道具（从卖家到买家）
      await this.itemService.transferItem(
        sellOrder.user_id,
        buyOrder.user_id,
        sellOrder.item_template_id,
        tradeAmount,
      );
      
      // 转移BB币（从系统锁定账户到卖家）
      const tradeCost = sellOrder.price * tradeAmount;
      await this.userService.addResource(
        sellOrder.user_id,
        'coin',
        tradeCost,
      );
      
      // 记录成交历史
      await this.logTrade(buyOrder, sellOrder, tradeAmount, sellOrder.price);
    });
    
    // 通知双方
    this.notificationService.emitToUser(buyOrder.user_id, 'exchange.deal', {
      type: 'buy',
      item: sellOrder.item_template.name,
      amount: tradeAmount,
      price: sellOrder.price,
    });
    
    this.notificationService.emitToUser(sellOrder.user_id, 'exchange.deal', {
      type: 'sell',
      item: sellOrder.item_template.name,
      amount: tradeAmount,
      price: sellOrder.price,
    });
  }
}
```

#### 2.7 通知模块 (Notification Module)

**WebSocket Gateway**：

```typescript
// notification/notification.gateway.ts
@WebSocketGateway({
  cors: { origin: '*' },
  namespace: '/game',
})
export class NotificationGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;
  
  private userSocketMap: Map<string, string> = new Map(); // userId -> socketId

  constructor(private jwtService: JwtService) {}

  // 客户端连接
  async handleConnection(client: Socket) {
    try {
      // 验证Token
      const token = client.handshake.auth.token;
      const payload = this.jwtService.verify(token);
      const userId = payload.sub;
      
      // 记录用户Socket映射
      this.userSocketMap.set(userId, client.id);
      client.data.userId = userId;
      
      console.log(`User ${userId} connected`);
    } catch (error) {
      client.disconnect();
    }
  }

  // 客户端断开
  handleDisconnect(client: Socket) {
    const userId = client.data.userId;
    if (userId) {
      this.userSocketMap.delete(userId);
      console.log(`User ${userId} disconnected`);
    }
  }

  // 向指定用户发送消息
  emitToUser(userId: string, event: string, data: any): void {
    const socketId = this.userSocketMap.get(userId);
    if (socketId) {
      this.server.to(socketId).emit(event, data);
    }
  }

  // 全服广播
  broadcastToAll(event: string, data: any): void {
    this.server.emit(event, data);
  }
}
```

---

## 数据库设计

### 表结构详细设计

#### 1. 用户表 (users)

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    wechat_openid VARCHAR(100) UNIQUE,
    nickname VARCHAR(50) DEFAULT '',
    avatar VARCHAR(255) DEFAULT '',
    level INT DEFAULT 1,
    ore_amount BIGINT DEFAULT 0,
    bb_coins BIGINT DEFAULT 0,
    experience BIGINT DEFAULT 0,
    is_vip BOOLEAN DEFAULT FALSE,
    vip_expire_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_level ON users(level);
CREATE INDEX idx_users_wechat ON users(wechat_openid);
```

#### 2. 道具模板表 (item_templates)

```sql
CREATE TABLE item_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    category VARCHAR(20) NOT NULL CHECK (category IN ('miner', 'cart', 'raider', 'shield')),
    description TEXT,
    icon_url VARCHAR(255),
    max_level INT DEFAULT 10,
    upgrade_formula JSONB, -- 升级配置
    created_at TIMESTAMP DEFAULT NOW()
);

-- 插入初始道具模板
INSERT INTO item_templates (name, category, description, max_level, upgrade_formula) VALUES
('青铜矿机', 'miner', '基础挖矿设备', 10, '{
  "1": {"materials": {"ore": 100, "coins": 500}, "success_rate": 0.95},
  "2": {"materials": {"ore": 200, "coins": 1000}, "success_rate": 0.90}
}'::jsonb),
('木制矿车', 'cart', '运输矿石的车辆', 10, '{}'::jsonb),
('生锈掠夺器', 'raider', '提升掠夺效率', 10, '{}'::jsonb),
('木制防御盾', 'shield', '减少被掠夺损失', 10, '{}'::jsonb);
```

#### 3. 用户道具表 (user_items)

```sql
CREATE TABLE user_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES item_templates(id),
    level INT DEFAULT 1,
    is_equipped BOOLEAN DEFAULT FALSE,
    is_locked BOOLEAN DEFAULT FALSE, -- 交易中锁定
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_user_items_user ON user_items(user_id);
CREATE INDEX idx_user_items_equipped ON user_items(user_id, is_equipped);
```

#### 4. 碎片表 (user_fragments)

```sql
CREATE TABLE user_fragments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES item_templates(id),
    amount INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, template_id)
);

CREATE INDEX idx_fragments_user ON user_fragments(user_id);
```

#### 5. 掠夺日志表 (plunder_logs)

```sql
CREATE TABLE plunder_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    attacker_id UUID NOT NULL REFERENCES users(id),
    defender_id UUID NOT NULL REFERENCES users(id),
    resources_looted BIGINT NOT NULL,
    attacker_raider_level INT,
    defender_shield_level INT,
    is_revenge BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_plunder_attacker ON plunder_logs(attacker_id, created_at);
CREATE INDEX idx_plunder_defender ON plunder_logs(defender_id, created_at);
```

#### 6. 交易订单表 (exchange_orders)

```sql
CREATE TABLE exchange_orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    item_template_id UUID NOT NULL REFERENCES item_templates(id),
    type VARCHAR(10) NOT NULL CHECK (type IN ('buy', 'sell')),
    price INT NOT NULL,
    amount INT NOT NULL,
    filled_amount INT DEFAULT 0,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'partial', 'filled', 'cancelled')),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_orders_matching ON exchange_orders(item_template_id, type, status, price);
CREATE INDEX idx_orders_user ON exchange_orders(user_id, created_at);
```

#### 7. 交易记录表 (exchange_trades)

```sql
CREATE TABLE exchange_trades (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    buy_order_id UUID NOT NULL REFERENCES exchange_orders(id),
    sell_order_id UUID NOT NULL REFERENCES exchange_orders(id),
    buyer_id UUID NOT NULL REFERENCES users(id),
    seller_id UUID NOT NULL REFERENCES users(id),
    item_template_id UUID NOT NULL REFERENCES item_templates(id),
    amount INT NOT NULL,
    price INT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_trades_item_time ON exchange_trades(item_template_id, created_at);
```

#### 8. 排行榜表 (season_rankings)

```sql
CREATE TABLE season_rankings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    season_id INT NOT NULL,
    user_id UUID NOT NULL REFERENCES users(id),
    rank INT NOT NULL,
    score BIGINT NOT NULL, -- 矿石累计产出
    reward_claimed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(season_id, user_id)
);

CREATE INDEX idx_rankings_season ON season_rankings(season_id, rank);
```

### Redis数据结构设计

#### 1. 用户会话
```
Key: user:{userId}
Type: String (JSON)
TTL: 1800s (30分钟)
Value: 完整用户信息
```

#### 2. 矿车存储
```
Key: cart:{userId}
Type: String (数字)
TTL: 永久
Value: 当前矿车存储量
```

#### 3. 矿洞坍塌状态
```
Key: collapse:{userId}
Type: String
TTL: 120s (坍塌持续时间)
Value: "1"
```

#### 4. 掠夺器冷却
```
Key: plunder_cd:{userId}
Type: String
TTL: 3600s (1小时)
Value: "1"
```

#### 5. 排行榜
```
Key: ranking:season:{seasonId}
Type: Sorted Set
Score: 矿石累计产出
Member: userId
```

---

## API接口设计

### RESTful API规范

**Base URL**: `https://api.yourgame.com/api`

**通用响应格式**:
```json
{
  "code": 200,
  "message": "success",
  "data": {}
}
```

**错误响应格式**:
```json
{
  "code": 400,
  "message": "错误描述",
  "error": "ERROR_CODE"
}
```

### 1. 认证接口

#### POST /auth/login
用户登录

**请求体**:
```json
{
  "username": "string",
  "password": "string"
}
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "access_token": "eyJhbGc...",
    "user": {
      "id": "uuid",
      "username": "player1",
      "nickname": "玩家1",
      "level": 5
    }
  }
}
```

#### POST /auth/wechat-login
微信登录

**请求体**:
```json
{
  "code": "微信授权code"
}
```

### 2. 用户接口

#### GET /user/profile
获取用户详情

**Headers**: `Authorization: Bearer {token}`

**响应**:
```json
{
  "code": 200,
  "data": {
    "id": "uuid",
    "nickname": "玩家1",
    "level": 5,
    "ore_amount": 12450,
    "bb_coins": 5230,
    "is_vip": false
  }
}
```

### 3. 挖矿接口

#### POST /mine/collect
收矿

**请求体**:
```json
{
  "watched_ad": true
}
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "collected_amount": 850
  }
}
```

### 4. 道具接口

#### GET /items
获取背包道具列表

**响应**:
```json
{
  "code": 200,
  "data": {
    "items": [
      {
        "id": "uuid",
        "template_id": "uuid",
        "name": "青铜矿机",
        "category": "miner",
        "level": 5,
        "is_equipped": true
      }
    ]
  }
}
```

#### POST /items/upgrade
升级道具

**请求体**:
```json
{
  "item_id": "uuid"
}
```

**响应**:
```json
{
  "code": 200,
  "data": {
    "success": true,
    "new_level": 6
  }
}
```

#### POST /items/compose
合成道具

**请求体**:
```json
{
  "template_id": "uuid"
}
```

### 5. 掠夺接口

#### GET /plunder/targets
获取可掠夺目标

**响应**:
```json
{
  "code": 200,
  "data": {
    "targets": [
      {
        "id": "uuid",
        "nickname": "玩家2",
        "level": 6,
        "estimated_loot": 500
      }
    ]
  }
}
```

#### POST /plunder/{targetId}
执行掠夺

**响应**:
```json
{
  "code": 200,
  "data": {
    "success": true,
    "loot_amount": 480,
    "can_revenge": true
  }
}
```

### 6. 交易所接口

#### GET /exchange/orders
查询挂单列表

**Query参数**:
- `item_template_id`: 道具模板ID
- `type`: buy/sell

**响应**:
```json
{
  "code": 200,
  "data": {
    "orders": [
      {
        "id": "uuid",
        "type": "sell",
        "price": 1000,
        "amount": 5,
        "filled_amount": 0
      }
    ]
  }
}
```

#### POST /exchange/orders
挂单

**请求体**:
```json
{
  "item_template_id": "uuid",
  "type": "buy",
  "price": 1000,
  "amount": 5
}
```

#### DELETE /exchange/orders/{orderId}
撤单

### WebSocket事件

#### 客户端→服务端

无主动发送事件（纯推送模式）

#### 服务端→客户端

| 事件名 | 数据结构 | 说明 |
|-------|---------|------|
| mine.update | `{type: 'normal/critical', amount: 100}` | 挖矿产出 |
| mine.collapse | `{repair_duration: 120}` | 矿洞坍塌 |
| plunder.attacked | `{attacker: 'xxx', loss: 300}` | 被掠夺通知 |
| item.upgrade_success | `{player: 'xxx', item: 'xxx +10'}` | 全服道具升级广播 |
| exchange.deal | `{type: 'buy', item: 'xxx', amount: 1, price: 1000}` | 交易成交通知 |

---

## 开发阶段规划

### 第一阶段：技术验证与核心框架（2周）

**目标**：搭建完整的前后端项目架构，跑通核心流程

#### Week 1: 基础设施搭建（本地单机可跑通）

**前端任务**:
- [ ] 创建 Cocos 项目 + 主题色/半透明底栏 + 字体接入
- [ ] 核心管理器（GameManager, NetworkManager, ThemeManager）
- [ ] 登录界面（玻璃卡片 + 霓虹输入框）
- [ ] 主界面基础卡片布局（渐变+发光）

**后端任务（简化，单机可用）**:
- [ ] 初始化 NestJS 项目（已完成）
- [ ] 仅启用 JWT + 内存用户存储（可选接 Postgres）
- [ ] 提供挖矿/道具/掠夺最小 API（已完成内存版）

**数据库任务（可选）**:
- [ ] 如需持久化再开启 DB_ENABLE 并生成迁移

#### Week 2: 核心流程打通

**前端任务**:
- [ ] 挖矿卡片：环形进度+实时数字（CountUp）
- [ ] 接入 WebSocket：mine.update/mine.collapse → UI 发光/倒计时
- [ ] 收矿操作（按钮涟漪 + Loading）

**后端任务**:
- [ ] 实现挖矿服务（MineService）
- [ ] 使用Bull队列模拟挖矿产出
- [ ] 实现收矿API
- [ ] 搭建WebSocket Gateway，推送挖矿产出

**测试验证**:
- [ ] 登录→开始挖矿→接收推送→收矿 完整流程跑通
- [ ] 数据持久化验证
- [ ] 性能初步测试（100并发用户）

---

### 第二阶段：核心循环开发（4周）

**目标**：完成主界面、仓库界面，实现挖矿、道具系统的完整功能

#### Week 3-4: 主界面完善 + 道具基础

**前端任务**:
- [ ] 科技风主界面卡片布局（紫蓝渐变背景）
- [ ] 暴击/坍塌效果（卡片发光脉冲 + 数字放大）
- [ ] 矿车进度条优化（渐变填充 + 实时百分比）
- [ ] 仓库界面开发（ScrollView 卡片列表）
- [ ] 道具详情弹窗（底部抽屉动画）

**后端任务**:
- [ ] 完善挖矿逻辑（暴击/坍塌概率）
- [ ] 实现道具模块基础CRUD
- [ ] 实现道具装备/卸载功能
- [ ] 道具属性加成计算

**UI 资源**:
- [ ] 扁平科技图标（道具 4 类）
- [ ] 霓虹描边样式 CSS
- [ ] 渐变背景配色方案

#### Week 5-6: 合成升级系统

**前端任务**:
- [ ] 道具升级交互流程（按钮禁用状态）
- [ ] 升级成功/失败效果（卡片脉冲 + 震动）
- [ ] 材料不足提示（Toast 半透明卡片）
- [ ] 碎片系统 UI（进度条 + 数字计数）

**后端任务**:
- [ ] 实现道具升级逻辑（含成功率计算）
- [ ] 实现碎片合成逻辑
- [ ] 材料扣除的原子性保证
- [ ] 高等级道具全服广播

**配置数据**:
- [ ] 设计完整的升级公式表
- [ ] 调整成功率曲线
- [ ] 设计碎片产出规则

**测试验证**:
- [ ] 完整游戏循环：挖矿→收矿→升级道具→提升产出
- [ ] 压力测试：1000用户同时升级道具
- [ ] 边界测试：材料不足、满级升级等

---

### 第三阶段：扩展玩法开发（4周）

**目标**：完成掠夺、交易所等扩展玩法

#### Week 7-8: 掠夺系统

**前端任务**:
- [ ] 掠夺界面UI开发
- [ ] 掠夺目标列表
- [ ] 掠夺战斗动画（简化版）
- [ ] 结算弹窗
- [ ] 被掠夺通知弹窗

**后端任务（本地最小）**:
- [ ] 目标列表（基于内存用户）
- [ ] 掠夺执行（简单公式、冷却、通知）

**可选扩展**:
- [ ] 掠夺日志记录（数据库）
- [ ] 复仇系统（Redis 过期）

**数据库任务**:
- [ ] 创建plunder_logs表
- [ ] 优化用户查询索引

#### Week 9-10: 交易所系统

**前端任务**:
- [ ] 交易所界面UI（多Tab切换）
- [ ] 挂单列表展示
- [ ] 挂买单/卖单弹窗
- [ ] 我的订单管理
- [ ] 价格走势图（可选）

**后端任务（可选）**:
- [ ] 实现订单 CRUD 与撮合引擎
- [ ] 交易原子性与历史记录
- [ ] 行情数据计算

**数据库任务**:
- [ ] 创建exchange_orders、exchange_trades表
- [ ] 优化撮合查询索引
- [ ] 设计订单状态机

**测试验证**:
- [ ] 撮合逻辑正确性测试
- [ ] 并发交易压力测试
- [ ] 资源转移原子性验证
- [ ] 边界情况：撤单、部分成交等

#### Week 10: 排行榜与赛季制

**前端任务**:
- [ ] 排行榜界面UI
- [ ] 排行榜数据刷新

**后端任务（可选）**:
- [ ] Redis 排行榜/赛季重置/奖励发放

---

### 第四阶段：优化与测试（3周）

**目标**：全面优化、测试、准备上线

#### Week 11: UI/UX优化

**前端任务**:
- [ ] 全局科技风统一（紫蓝配色 + 霓虹描边）
- [ ] 音效集成（按钮点击、暴击、升级成功等，可选）
- [ ] 新手引导流程（蒙层高亮 + 箭头指示）
- [ ] 加载动画优化（圆环进度 + 渐变旋转）
- [ ] 适配不同分辨率（响应式布局）

**UI 资源**:
- [ ] 最终配色方案确定（渐变色值）
- [ ] 霓虹描边与阴影 CSS 样式
- [ ] 扁平图标库（SVG 或 PNG）

#### Week 12: 性能优化与安全加固

**前端优化**:
- [ ] 资源预加载优化
- [ ] 内存泄漏排查
- [ ] 网络请求优化（合并、缓存）
- [ ] 包体大小优化

**后端优化**:
- [ ] 数据库查询优化（慢查询排查）
- [ ] Redis缓存策略优化
- [ ] API限流（防刷）
- [ ] 敏感操作日志审计

**安全加固**:
- [ ] 防止客户端作弊（所有计算在服务端）
- [ ] API签名验证
- [ ] SQL注入防护
- [ ] XSS防护

#### Week 13: 全面测试

**功能测试**:
- [ ] 完整功能回归测试
- [ ] 边界情况测试
- [ ] 异常流程测试

**性能测试**:
- [ ] 压力测试（模拟10000在线用户）
- [ ] 接口响应时间测试
- [ ] 数据库连接池测试

**兼容性测试**:
- [ ] iOS Safari测试
- [ ] Android Chrome测试
- [ ] 微信内置浏览器测试
- [ ] 不同屏幕尺寸测试

**Bug修复**:
- [ ] 收集并修复测试期间发现的所有Bug

---

## 部署与运维（本地为主，以下为可选参考）

### 1. 部署架构

```
                 ┌─────────────┐
                 │   CDN/OSS   │ ← 静态资源
                 └─────────────┘
                        │
┌────────────────────────┼────────────────────────┐
│                        ↓                        │
│              ┌──────────────────┐              │
│              │   Nginx (反向代理)  │             │
│              └──────────────────┘              │
│                        │                        │
│        ┌───────────────┼───────────────┐       │
│        ↓               ↓               ↓       │
│   ┌────────┐     ┌────────┐     ┌────────┐   │
│   │ Node.js│     │ Node.js│     │ Node.js│   │  后端服务集群
│   │ Server │     │ Server │     │ Server │   │  (PM2管理)
│   └────────┘     └────────┘     └────────┘   │
│        └───────────────┬───────────────┘       │
│                        │                        │
│              ┌──────────────────┐              │
│              │   PostgreSQL     │              │
│              │   (主从复制)      │              │
│              └──────────────────┘              │
│                        │                        │
│              ┌──────────────────┐              │
│              │  Redis Cluster   │              │
│              └──────────────────┘              │
└─────────────────────────────────────────────────┘
```

### 2. 部署清单

#### 前端部署（本地）
```bash
# 本地调试直接使用 Cocos 预览/本地静态服务器
npm run build # 如需产物
```

#### 后端部署（本地）
```bash
# 开发模式
npm install
npm run start:dev
```

> 生产级部署（Nginx/CDN/PM2/主从/集群等）为可选内容，不影响本地功能验证。

### 3. 监控与日志

**监控指标**:
- API响应时间
- 数据库连接数
- 服务器CPU/内存使用率
- 在线用户数
- 错误率

**日志收集**:
- 应用日志（Winston）
- 访问日志（Nginx）
- 错误日志集中存储

### 4. 运维脚本

**数据库备份**:
```bash
#!/bin/bash
# backup-db.sh
pg_dump mining_game > backup_$(date +%Y%m%d).sql
# 上传到OSS
```

**赛季重置**:
```bash
# 定时任务：每月1号凌晨执行
0 0 1 * * /usr/local/bin/reset-season.sh
```

---

## 附录

### A. 关键配置参数

| 配置项 | 值 | 说明 |
|-------|---|------|
| 挖矿基础间隔 | 60秒 | 矿机每级-2秒 |
| 暴击概率 | 25% | 3倍产出 |
| 坍塌概率 | 5% | 停工2分钟 |
| 矿车基础容量 | 1000 | 矿车每级+1000 |
| 掠夺器冷却 | 1小时 | VIP减半 |
| 掠夺基础成功率 | 10% | 装备影响±5% |
| 道具升级基础成功率 | 80% | 每级-5% |

### B. 技术选型替代方案

| 原方案 | 替代方案 | 说明 |
|-------|---------|------|
| Cocos Creator | Phaser.js | 更轻量的H5游戏引擎 |
| NestJS | Express.js | 更轻量，但需自行搭建架构 |
| PostgreSQL | MySQL | 更常见，但JSON支持较弱 |
| Bull | Bee-Queue | 更轻量的队列库 |

### C. 开发规范

**代码规范**:
- 使用ESLint + Prettier
- 遵循Airbnb编码风格
- 提交前执行lint检查

**Git工作流**:
- main分支：生产环境
- develop分支：开发环境
- feature/*分支：功能开发
- 使用Pull Request进行代码审查

**命名规范**:
- 变量/函数：camelCase
- 类/接口：PascalCase
- 常量：UPPER_SNAKE_CASE
- 文件名：kebab-case



